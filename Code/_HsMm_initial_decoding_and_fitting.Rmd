---
title: "Decoding and Model Fitting"
author: "Laura Symul"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  bookdown::html_document2: 
    theme: flatly
    highlight: haddock
    toc: yes
    toc_float: true
    toc_depth: 5
    number_sections: true
    fig_caption: true
---

```{r idecod knitr setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
```

```{r idecod setup, include = FALSE, eval = TRUE, cache = FALSE}
source("Scripts/00_setup.R")
```

# Decoding and Model Fitting


## Users subset selection

To fit the model, we will use the time-series of a diverse subset of users.

We will select users from these different categories:

1. Users with pregnancies

2. Users with many observations (mucus, temperature, LH tests)

3. Users with few observations (just period)

4. Users with very long time-series

5. Users with long and with short cycles

6. Both users who declared wanted to achieve and to avoid pregnancies


```{r idecod users selection}

users = read_feather(path = str_c(IO$output_data,"users.feather"))

top_n = 30

u1 = users %>% dplyr::filter(n_pos_preg_test > 0,
                             n_days_obs >= 365,
                             (batch %% 10) == 0 ) %>% mutate(u_type = "1") %>% head(top_n)

u2 = users %>% dplyr::filter(n_days_obs >= 365,
                             n_days_obs < 365*2,
                             (n_temp/n_days_obs >= 1/2) | (n_mucus/n_days_obs >= 1/4) |  (n_LH_test/n_days_obs >= 1/10),
                             (batch %% 10) == 0)%>% mutate(u_type = "2") %>% head(top_n)


u3 = users %>% dplyr::filter(n_days_obs >= 365,
                             n_days_obs < 365*2,
                             (n_temp < 10) & (n_mucus < 5) &  (n_LH_test<3),
                             (batch %% 10) == 0)%>% mutate(u_type = "3") %>% head(top_n)


u4 = users %>% dplyr::filter(n_days_obs >= 5*365,
                             (batch %% 10) == 0)%>%  mutate(u_type = "4") %>% head(top_n)


u5 = users %>% dplyr::filter(round(average_cycle) %in% c(20,40),
                             round(average_luteal) %in% c(11:14),
                             n_days_obs >= 365,
                             n_days_obs < 365*2,
                             (batch %% 10) == 0)%>%  mutate(u_type = "5") %>% head(top_n)


u = rbind(u1,u2,u3,u4,u5)
u = ddply(u, .(user_id, batch), summarize,
          u_type = min(u_type))
u = u %>%  arrange(u_type, batch, user_id)

dim(u)

```

```{r idecod retrieving their observations}

days_selected_users = foreach(b = unique(u$batch), .combine = rbind) %do% {
  cat(b,"\n")
  days = read_feather(path = str_c(IO$output_data,"Days/days_",b,".feather"))
  days = days %>% dplyr::filter(user_id %in% u$user_id)
  days
}

write_feather(days_selected_users, path = str_c(IO$tmp_data,"days_selected_users.feather"))

```




## Loading model and data


We load the initial model, i.e. the model whose parameters and architecture are specified based on biological/medical literature and based on the prior-analysis of the datasets (for calibration of temperature variations, mucus categories, etc.).

```{r idecod load the general semi-markov model}

load(file = paste0(IO$tmp_data, "hsmm.Rdata"), verbose = TRUE)

```


We load the manual labels.

```{r idecod load the manual labels}

manual_labels = read_feather(path = paste0(IO$output_data, "manual_labels.feather"))

manual_labels = manual_labels %>% dplyr::mutate(
  state_abbr = hsmm$states$abbr[match(state_name, hsmm$states$names)]
)

```


We load the users time-series

```{r idecod load the users time series}

days = read_feather(path = str_c(IO$tmp_data,"days_selected_users.feather"))

```


We count the number of days with manual labels for each states

```{r number of days with manual labels by states}

manual_labels_agg = manual_labels %>% dplyr::filter(user_id %in% unique(days$user_id)) %>% 
  group_by(state_abbr) %>% dplyr::summarize(counts = n()) %>% 
  dplyr::rename(true = state_abbr) %>% 
  dplyr::mutate(true = factor(true, levels = rev(hsmm$states$abbr))) %>% 
  arrange(desc(true))

nb_of_labelled_states = ggplot(manual_labels_agg, 
                               aes(x = 1, y = true , fill = counts))+ 
  coord_fixed()+
  geom_tile()+
  geom_hline(yintercept = 0:hsmm$n_states+0.5, size = 0.1)+
  scale_fill_gradient(name = "# of labelled days\nwith this state",low = "white", high = "wheat4")+
  ylab("")+
  xlab("")+
  theme(legend.position = "bottom",
        legend.title = element_text(vjust = 0.75),
        axis.title.y = element_text(angle = 0, hjust = 1, vjust = 1),
        axis.title.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.text.x = element_blank())

nb_of_labelled_states_no_legend = nb_of_labelled_states + theme(legend.position = "none")
nb_of_labelled_states_no_legend
ggsave(nb_of_labelled_states_no_legend, filename = str_c(IO$panels,"nb_of_labelled_states.pdf"), 
       width = viz$full_width/10, height = viz$full_width/2.5)

nb_of_labelled_states_legend = get_legend(nb_of_labelled_states)
nb_of_labelled_states_legend = as_ggplot(nb_of_labelled_states_legend)
ggsave(nb_of_labelled_states_legend, filename = str_c(IO$panels,"nb_of_labelled_states_legend.pdf"), 
       width = viz$full_width/4, height = viz$full_width/12)

nb_of_labelled_states

```


Folder to save the decodings

```{r folder to save the decodings}
folder = paste0(IO$output_data,"decoding/")
if(!dir.exists(folder)){dir.create(folder)}
```



## Rule-based decoding


```{r rule-based decoding}

#s_days = days %>% dplyr::filter(user_id %in% unique(days$user_id)[91:114])

source("Scripts/rule_based_labelling_functions.R")

tic()
rule_based_decoding = rule_based_labelling(days)
toc()


tmp = full_join(x = rule_based_decoding, 
                y = manual_labels %>% 
                  dplyr::select(user_id, rel_date, state_name, state_abbr) %>% 
                  dplyr::rename(manual_label_state_name = state_name,
                                manual_label_state_abbr = state_abbr) %>% 
                  dplyr::filter(user_id %in% unique(days$user_id)), 
                by = c("user_id","rel_date")) %>% 
  dplyr::mutate(correct_decoding = (state_name == manual_label_state_name))

rule_based_decoding = tmp

rule_based_decoding$cs = NA

rm(tmp)

```

```{r save rule-based decoding}

write_feather(rule_based_decoding, path = str_c(folder, "rule_based_decoding.feather"))

```

### Performances

#### Accuracy

Overall accuracy = fraction of correct decoded labels

```{r rule-based accuracy}

A_rb = mean(rule_based_decoding$correct_decoding, na.rm = TRUE)

cat("Accuracy of the rule-based decoding: ",A_rb,"\n")

```

#### Confusion matrix

Fraction of manual labels correctly decoded

```{r rule-based confusion matrix}

confusion_matrix_viz_rule_based = ggplot_confusion_matrix(
  true =  rule_based_decoding$manual_label_state_abbr,
  decoded = hsmm$states$abbr[rule_based_decoding$state_num])
confusion_matrix_viz_rule_based + ggtitle("Rule-based")

confusion_matrix_viz_no_legend = confusion_matrix_viz_rule_based + theme(legend.position = "none")
ggsave(confusion_matrix_viz_no_legend, filename = str_c(IO$panels,"confusion_matrix_baseline.pdf"), 
       width = viz$full_width/2.5, height = viz$full_width/2.5)

confusion_matrix_legend = get_legend(confusion_matrix_viz_rule_based)
confusion_matrix_legend = as_ggplot(confusion_matrix_legend)
ggsave(confusion_matrix_legend, filename = str_c(IO$panels,"confusion_matrix_baseline_legend.pdf"), 
       width = viz$full_width/4, height = viz$full_width/12)

```


#### Special events timing accuracy

The timing of some events are especially critical, i.e. the timing of ovulations, births and losses.

For each of these labelled events, we look if a corresponding state was decoded within a 30-day window and, if it was, we look at the time-difference between the manual label and the decoded state.

```{r event accuracy for baseline}

baseline_event_accuracy = event_accuracy(decoding = rule_based_decoding, manual_labels = manual_labels, events = c("Ovu", "Birth","Loss"))

baseline_event_accuracy_plot = ggplot_event_accuracy(event_accuracy = baseline_event_accuracy)

baseline_event_accuracy_plot

```


#### Sequences with many days of incorrect decoding

```{r bad decoding sequences baseline}

decoding_agg_rule_based = rule_based_decoding %>% 
  group_by(user_id) %>% 
  dplyr::summarise(n_days = n(),
                   n_days_incorrect_decoding = sum(!correct_decoding, na.rm = TRUE),
                   percent_incorrect_decoding = n_days_incorrect_decoding/n_days *100) %>% 
  arrange(desc(percent_incorrect_decoding)) %>% 
  dplyr::mutate(user_id = factor(user_id, levels = user_id))

perc_of_incorrect_decoding_per_user_rule_based = 
  ggplot(decoding_agg_rule_based, aes(x = rev(user_id), y = percent_incorrect_decoding))+
  geom_bar(stat = "identity")+
  coord_flip()

perc_of_incorrect_decoding_per_user_rule_based + ggtitle("Rule-based")
  
for(user in decoding_agg_rule_based$user_id[1:10]){
  d = days %>% dplyr::filter(user_id == user)
  dec = rule_based_decoding %>% dplyr::filter(user_id == user) %>% 
    dplyr::mutate(cs = 1)
  
  states_labels_list = list(
    rule_based =  dec %>% dplyr::select(user_id, rel_date, color, cs) %>%  
      mutate(name = "Rule-based"), 
    difference_with_ground_truth = dec %>% 
      mutate(color = c("red","steelblue2")[correct_decoding+1], name = "Diff w/\nground truth") %>% 
      dplyr::select(user_id, rel_date, color, alpha = cs),
    manual_labels = manual_labels %>% dplyr::filter(user_id == user)%>%  
      mutate(name = "States\n(manual labels)")
  )
  
  try({
    p = plot_user_history(d = d, states_labels_list = states_labels_list)
    print(p)
  })
  
}


```



## Semi-Markov decoding

### Preparing the observations

The original features as tracked by the users in the app are transformed into the "observed variables".

These transformations include switching from categorical data to discrete scores or results of basic time-series analyses such as computing the maximal auto-correlation score to provide a proxi for the regularity of the bleeding patterns.


```{r idecod preparing the observations}

obs = foreach(user = unique(days$user_id) , .combine = rbind)%do%{
  d = days[which(days$user_id == user),]
  d = d[order(d$date),]
  this_user_obs = create_observation_scores(d = d, features = hsmm$obs_names)
  this_user_obs$user_id = this_user_obs$user_id %>% as.character()
  return(this_user_obs)
}

#obs_full = obs
#obs = obs_full # %>% dplyr::filter(user_id %in% unique(obs_full$user_id)[1:100])

obs_mat = obs %>%  dplyr::select(str_c(hsmm$obs_names, "_score")) %>% as.matrix()
colnames(obs_mat) = colnames(obs_mat) %>%  str_replace(.,"_score","")
N = rle(obs$user_id)$length; names(N) = rle(obs$user_id)$values

obsdata = list(N = N, x = obs_mat); class(obsdata) = "hsmm.data"

# matching the manual labels
j = match(str_c(obs$user_id,"_",obs$rel_date),str_c(manual_labels$user_id,"_",manual_labels$rel_date))
labels = data.frame(state = match(manual_labels$state_name, hsmm$states$names)[j], weight = c(1/2,1)[match(manual_labels$type[j],c("V","M"))])

```




### Decoding with model with initial parameter values

```{r idecod modified package functions, include = FALSE}

source("Scripts/mhsmm_LSY/R/hsmm_functions.R")
source("Scripts/mhsmm_LSY/R/spec_functions.R")

```


```{r idecod decoding, warning=FALSE}

# building the hsmm model
hsmm_init = bluid_hsmm(hsmm, M = max(N))

# Decoding
tic()
viterbi_init = predict.hsmmspec(object = hsmm_init, newdata = obsdata, method = "viterbi")
toc()
# tic()
# smoothed_init = predict.hsmmspec(object = hsmm_init, newdata = obsdata, method = "smoothed", debug = FALSE)
# toc()

tic()
smoothed_init = list()
smoothed_init$p = matrix(0, nrow = nrow(obs), ncol = hsmm$n_states)
smoothed_init$s = rep(0, nrow(obs))
problematic_users = c()
obsdata_for_fit = list(); class(obsdata_for_fit) = "hsmm.data"
labels_for_fit = data.frame()
for(i in 1:length(obsdata$N)){
  cat("USER ",i,"\n")
  this_user_N = obsdata$N[i]
  j = which(obs$user_id == names(this_user_N))
  length(j);
  this_user_obsdata = list(N = this_user_N, x = obsdata$x[j,])
  class(this_user_obsdata) = "hsmm.data"
  
  this_user_smoothed_init = try(predict.hsmmspec(object = hsmm_init, newdata = this_user_obsdata, method = "smoothed", debug = FALSE))
  if(class(this_user_smoothed_init) == "try-error"){
    this_user_p = matrix(0, nrow = this_user_N, ncol = hsmm$n_states)
    this_user_s = rep(NA, this_user_N)
    problematic_users = c(problematic_users, i)
  }else{
    this_user_p = this_user_smoothed_init$p
    this_user_s = this_user_smoothed_init$s
    if(i == 1){
      obsdata_for_fit$N = this_user_N; obsdata_for_fit$x = obsdata$x[j,]
    }else{
      obsdata_for_fit$N = c(obsdata_for_fit$N, this_user_N); obsdata_for_fit$x = rbind(obsdata_for_fit$x, obsdata$x[j,])
    }
    labels_for_fit = rbind(labels_for_fit, labels[j,])
  }
  smoothed_init$p[j,] = this_user_p
  smoothed_init$s[j] = this_user_s
}
toc()


```



```{r initial model - formatting the results}

viterbi_states_init = data.frame(user_id = obs$user_id, 
                                 rel_date = obs$rel_date, 
                                 label_id = as.character(now()),
                                 state_name = hsmm$states$names[viterbi_init$s], 
                                 color = hsmm$states$colors[viterbi_init$s], 
                                 type = "viterbi",
                                 state_num = viterbi_init$s,
                                 stringsAsFactors = FALSE)

smoothed_states_init = data.frame(user_id = obs$user_id, 
                                  rel_date = obs$rel_date, 
                                  label_id = as.character(now()),
                                  state_name = hsmm$states$names[smoothed_init$s], 
                                  color = hsmm$states$colors[smoothed_init$s], 
                                  type = "smoothed",
                                  state_num = smoothed_init$s,
                                  stringsAsFactors = FALSE)


state_prob_init = data.frame(smoothed_init$p) %>%  set_colnames(1:hsmm$n_states) %>%  mutate(user_id = obs$user_id, rel_date = obs$rel_date)
state_prob_long_init = melt(state_prob_init, id.vars = c("user_id","rel_date")) %>%  
  mutate(color =  hsmm$states$colors[variable], prob = value) %>%  
  dplyr::rename(state_num = variable)

```




```{r initial model - adding the manual labels}


tmp = full_join(x = viterbi_states_init, 
                y = manual_labels %>% 
                  dplyr::select(user_id, rel_date, state_name, state_abbr) %>% 
                  dplyr::rename(manual_label_state_name = state_name,
                                manual_label_state_abbr = state_abbr) %>% 
                  dplyr::filter(user_id %in% unique(days$user_id)), 
                by = c("user_id","rel_date")) %>% 
  dplyr::mutate(correct_decoding = (state_name == manual_label_state_name))

viterbi_states_init = tmp



tmp = full_join(x = smoothed_states_init, 
                y = manual_labels %>% 
                  dplyr::select(user_id, rel_date, state_name, state_abbr) %>% 
                  dplyr::rename(manual_label_state_name = state_name,
                                manual_label_state_abbr = state_abbr) %>% 
                  dplyr::filter(user_id %in% unique(days$user_id)), 
                by = c("user_id","rel_date")) %>% 
  dplyr::mutate(correct_decoding = (state_name == manual_label_state_name))

smoothed_states_init = tmp



```



```{r initial model - computing the confidence score}

LL = compute_log_likelihood(state_decoded_seq = viterbi_states_init, model = hsmm_init, obsdata = obsdata, N = 100)
viterbi_states_init$loglik = LL$loglik
viterbi_states_init$loglik_b = LL$loglik_b
viterbi_states_init$LR = LL$LR
viterbi_states_init$cs = LL$cs

hist(viterbi_states_init$cs)



LL = compute_log_likelihood(state_decoded_seq = smoothed_states_init, model = hsmm_init, obsdata = obsdata, N = 100)
smoothed_states_init$loglik = LL$loglik
smoothed_states_init$loglik_b = LL$loglik_b
smoothed_states_init$LR = LL$LR
smoothed_states_init$cs = LL$cs


smoothed_states_init$manually_labelled_states = hsmm$states$abbr[labels$state]

hist(smoothed_states_init$cs)

```




```{r initial model - saving decoding}

write_feather(viterbi_states_init, path = paste0(folder,"viterbi_states_init.feather"))
write_feather(smoothed_states_init, path = paste0(folder,"smoothed_states_init.feather"))
write_feather(state_prob_long_init, path = paste0(folder,"smoothed_probs_init.feather"))

```


#### Performances of decoding with Semi-Markov Model; initial parameter values


##### Accuracy

```{r idecod accuracy of initial model}

# Viterbi Accuracy

A_V_i = mean(viterbi_states_init$correct_decoding, na.rm = TRUE)
cat("Accuracy of the viterbi decoding with model with initial parameters: ",A_V_i,"\n")

# Backward Forward Accuracy 

#mx = 1:nrow(labels)
#my = labels$state
#A_i = mean(smoothed_init$p[cbind(mx,my)], na.rm = TRUE)

A_i = mean(smoothed_states_init$correct_decoding, na.rm = TRUE)
cat("Accuracy of the model with initial parameters: ",A_i,"\n")


```

##### Confusion matrix

```{r confusion matrix initial model}


confusion_matrix_viz = ggplot_confusion_matrix(
  true =  smoothed_states_init$manual_label_state_abbr,
  decoded = hsmm$states$abbr[smoothed_states_init$state_num])
confusion_matrix_viz + ggtitle("Backward/Forward decoding")

confusion_matrix_viz_no_legend = confusion_matrix_viz + theme(legend.position = "none")
ggsave(confusion_matrix_viz_no_legend, filename = str_c(IO$panels,"confusion_matrix_smoothed_init.pdf"), 
       width = viz$full_width/2.5, height = viz$full_width/2.5)

confusion_matrix_legend = get_legend(confusion_matrix_viz)
confusion_matrix_legend = as_ggplot(confusion_matrix_legend)
ggsave(confusion_matrix_legend, filename = str_c(IO$panels,"confusion_matrix_smoothed_init_legend.pdf"), 
       width = viz$full_width/4, height = viz$full_width/12)





confusion_matrix_viz = ggplot_confusion_matrix(
  true =  smoothed_states_init$manual_label_state_abbr,
  decoded = hsmm$states$abbr[viterbi_states_init$state_num])
confusion_matrix_viz + ggtitle("Viterbi decoding")



```


##### Special events timing accuracy


```{r event accuracy for smoothed and viterbi initial model}

smoothed_event_accuracy = event_accuracy(decoding = smoothed_states_init, 
                                         manual_labels = manual_labels, 
                                         events = c("Ovu", "Birth","Loss"))

smoothed_init_event_accuracy_plot = ggplot_event_accuracy(event_accuracy = smoothed_event_accuracy)

smoothed_init_event_accuracy_plot



viterbi_event_accuracy = event_accuracy(decoding = viterbi_states_init, 
                                         manual_labels = manual_labels, 
                                         events = c("Ovu", "Birth","Loss"))

viterbi_init_event_accuracy_plot = ggplot_event_accuracy(event_accuracy = viterbi_event_accuracy)

viterbi_init_event_accuracy_plot


```


##### Confidence in decoding


```{r idecod confidence in decoding init model - VIZ, fig.width=3.5, fig.height=3}


m = match(smoothed_states_init$correct_decoding,c(TRUE, FALSE, NA))
smoothed_states_init$decoding_accuracy = c("correct\ndecoding","incorrect\ndecoding","no\nmanual labels")[m]

confidence_score_dist_smoothed_init = ggplot(smoothed_states_init, aes(x = cs, fill = decoding_accuracy))
confidence_score_dist_smoothed_init = confidence_score_dist_smoothed_init +
  geom_histogram(binwidth = 0.05)+
  facet_grid(decoding_accuracy ~., scale = "free", drop = TRUE)+
  scale_fill_manual(values = c("seagreen3","salmon","gray70"))+
  xlab("confidence score")+
  guides(fill = FALSE)

confidence_score_dist_smoothed_init

ggsave(confidence_score_dist_smoothed_init, filename = str_c(IO$panels,"confidence_score_dist_smoothed_init.pdf"),
       width = viz$full_width/3, height = viz$full_width/4)




m = match(viterbi_states_init$correct_decoding,c(TRUE, FALSE, NA))
viterbi_states_init$decoding_accuracy = c("correct\ndecoding","incorrect\ndecoding","no\nmanual labels")[m]

confidence_score_dist_viterbi_init = ggplot(viterbi_states_init, aes(x = cs, fill = decoding_accuracy))
confidence_score_dist_viterbi_init = confidence_score_dist_viterbi_init +
  geom_histogram(binwidth = 0.05)+
  facet_grid(decoding_accuracy ~., scale = "free", drop = TRUE)+
  scale_fill_manual(values = c("seagreen3","salmon","gray70"))+
  xlab("confidence score")+
  guides(fill = FALSE)

confidence_score_dist_viterbi_init

ggsave(confidence_score_dist_viterbi_init, filename = str_c(IO$panels,"confidence_score_dist_viterbi_init.pdf"),
       width = viz$full_width/3, height = viz$full_width/4)


```


##### Sequences with many days of incorrect decoding

```{r bad decoding sequences init model}

# Viterbi

decoding_agg_viterbi_init = viterbi_states_init %>% 
  group_by(user_id) %>% 
  dplyr::summarise(n_days = n(),
                   n_days_incorrect_decoding = sum(!correct_decoding, na.rm = TRUE),
                   percent_incorrect_decoding = n_days_incorrect_decoding/n_days *100) %>% 
  arrange(desc(percent_incorrect_decoding)) %>% 
  dplyr::mutate(user_id = factor(user_id, levels = user_id))

perc_of_incorrect_decoding_per_user_viterbi_init = 
  ggplot(decoding_agg_viterbi_init, aes(x = rev(user_id), y = percent_incorrect_decoding))+
  geom_bar(stat = "identity")+
  coord_flip()

perc_of_incorrect_decoding_per_user_viterbi_init + ggtitle("Viterbi; initial parameters")

# Smoothed

decoding_agg_smooted_init = smoothed_states_init %>% 
  group_by(user_id) %>% 
  dplyr::summarise(n_days = n(),
                   n_days_incorrect_decoding = sum(!correct_decoding, na.rm = TRUE),
                   percent_incorrect_decoding = n_days_incorrect_decoding/n_days *100) %>% 
  arrange(desc(percent_incorrect_decoding)) %>% 
  dplyr::mutate(user_id = factor(user_id, levels = user_id))

perc_of_incorrect_decoding_per_user_smoothed_init = 
  ggplot(decoding_agg_smooted_init, aes(x = rev(user_id), y = percent_incorrect_decoding))+
  geom_bar(stat = "identity")+
  coord_flip()

perc_of_incorrect_decoding_per_user_smoothed_init + ggtitle("Forward-Backward; initial parameters")
  


for(user in decoding_agg_smooted_init$user_id[1:10]){
  d = days %>% dplyr::filter(user_id == user)
  dec = smoothed_states_init %>% dplyr::filter(user_id == user) %>% 
    dplyr::mutate(cs = 1)
  
  states_labels_list = list(
    smoothed =  dec %>% dplyr::select(user_id, rel_date, color, cs) %>%  
      mutate(name = "Smoothed"), 
    difference_with_ground_truth = dec %>% 
      mutate(color = c("red","steelblue2")[correct_decoding+1], name = "Diff w/\nground truth") %>% 
      dplyr::select(user_id, rel_date, color, alpha = cs),
    manual_labels = manual_labels %>% dplyr::filter(user_id == user)%>%  
      mutate(name = "States\n(manual labels)")
  )
  
  try({
    p = plot_user_history(d = d, states_labels_list = states_labels_list)
    print(p)
  })
  
}


```




### Fitting


```{r idecod fitting}

# Fitting
tic()
hsmm_fitted = hsmmfit(x = obsdata_for_fit, model = hsmm_init, label = labels_for_fit, maxit = 1, 
                      lock.d = TRUE, lock.transition = TRUE, graphical = FALSE, debug = TRUE)
toc()
names(hsmm_fitted)


# Saving the fitted model
save(hsmm_fitted, file = paste0(IO$output_data, "hsmm_fitted.Rdata"))

```

### Decoding with fitted model

```{r idecod decoding with fitted model}

# Decode with the fitted model VITERBI
viterbi_fitted = predict.hsmm(object = hsmm_fitted, newdata = obsdata, method = "viterbi")

# Decode with the fitted model SMOOTHED
#smoothed_fitted = predict.hsmm(object = hsmm_fitted, newdata = obsdata, method = "smoothed", debug = FALSE) #buggy

smoothed_fitted = list()
smoothed_fitted$p = 0*smoothed_init$p
smoothed_fitted$s = 0*smoothed_init$s
for(i in 1:length(obsdata$N)){
  cat("USER ",i,"\n")
  this_user_N = obsdata$N[i]
  j = which(obs$user_id == names(this_user_N))
  length(j);
  #if(i == 5){j = j[1915:2579];this_user_N = length(j)}
  #if(i == 54){j = j[1472:3869];this_user_N = length(j)}
  #if(i == 60){j = j[1537:2449];this_user_N = length(j)}
  #length(j)
  this_user_obsdata = list(N = this_user_N, x = obsdata$x[j,])
  class(this_user_obsdata) = "hsmm.data"
  
  #this_user_smoothed_init = try(predict.hsmmspec(object = hsmm_init, newdata = this_user_obsdata, method = "smoothed", debug = FALSE))
  
  this_user_smoothed_fitted = try(predict.hsmm(object = hsmm_fitted, newdata = this_user_obsdata, method = "smoothed", debug = FALSE))
  if(class(this_user_smoothed_fitted) == "try-error"){
    this_user_p = matrix(0, nrow = this_user_N, ncol = hsmm$n_states)
    this_user_s = rep(NA, this_user_N)
  }else{
    this_user_p = this_user_smoothed_fitted$p
    this_user_s = this_user_smoothed_fitted$s
    
  }
  smoothed_fitted$p[j,] = this_user_p
  smoothed_fitted$s[j] = this_user_s
}

```



```{r fitted model - formatting the results}

# Saving results
viterbi_states_fitted = data.frame(user_id = obs$user_id, 
                                   rel_date = obs$rel_date, 
                                   label_id = as.character(now()),
                                   state_name = hsmm$states$names[viterbi_fitted$s], 
                                   color = hsmm$states$colors[viterbi_fitted$s], 
                                   type = "viterbi",
                                   state_num = viterbi_fitted$s,
                                   stringsAsFactors = FALSE)

smoothed_states_fitted = data.frame(user_id = obs$user_id, 
                                    rel_date = obs$rel_date, 
                                    label_id = as.character(now()),
                                    state_name = hsmm$states$names[smoothed_fitted$s], 
                                    color = hsmm$states$colors[smoothed_fitted$s], 
                                    type = "smoothed",
                                    state_num = smoothed_fitted$s,
                                    stringsAsFactors = FALSE)


state_prob_fitted = data.frame(smoothed_fitted$p) %>%  set_colnames(1:hsmm$n_states) %>%  mutate(user_id = obs$user_id, rel_date = obs$rel_date)
state_prob_long_fitted = melt(state_prob_fitted, id.vars = c("user_id","rel_date")) %>%  
  mutate(color =  hsmm$states$colors[variable], prob = value) %>%  
  dplyr::rename(state_num = variable)

```





```{r fitted model - adding the manual labels}

tmp = full_join(x = viterbi_states_fitted, 
                y = manual_labels %>% 
                  dplyr::select(user_id, rel_date, state_name, state_abbr) %>% 
                  dplyr::rename(manual_label_state_name = state_name,
                                manual_label_state_abbr = state_abbr) %>% 
                  dplyr::filter(user_id %in% unique(days$user_id)), 
                by = c("user_id","rel_date")) %>% 
  dplyr::mutate(correct_decoding = (state_name == manual_label_state_name))

viterbi_states_fitted = tmp


tmp = full_join(x = smoothed_states_fitted, 
                y = manual_labels %>% 
                  dplyr::select(user_id, rel_date, state_name, state_abbr) %>% 
                  dplyr::rename(manual_label_state_name = state_name,
                                manual_label_state_abbr = state_abbr) %>% 
                  dplyr::filter(user_id %in% unique(days$user_id)), 
                by = c("user_id","rel_date")) %>% 
  dplyr::mutate(correct_decoding = (state_name == manual_label_state_name))

smoothed_states_fitted = tmp

```


```{r fitted model - computing the confidence score}

LL = compute_log_likelihood(state_decoded_seq = viterbi_states_fitted, model = hsmm_fitted$model, 
                            obsdata = obsdata, N = 100)
viterbi_states_fitted$loglik = LL$loglik
viterbi_states_fitted$loglik_b = LL$loglik_b
viterbi_states_fitted$LR = LL$LR
viterbi_states_fitted$cs = LL$cs

hist(viterbi_states_fitted$cs)



LL = compute_log_likelihood(state_decoded_seq = smoothed_states_fitted, model = hsmm_fitted$model, 
                            obsdata = obsdata, N = 100)
smoothed_states_fitted$loglik = LL$loglik
smoothed_states_fitted$loglik_b = LL$loglik_b
smoothed_states_fitted$LR = LL$LR
smoothed_states_fitted$cs = LL$cs

hist(smoothed_states_fitted$cs)

```


```{r fitted model - saving decoding}
write_feather(viterbi_states_fitted, path = paste0(folder,"viterbi_states_fitted.feather"))
write_feather(smoothed_states_fitted, path = paste0(folder,"smoothed_states_fitted.feather"))
write_feather(state_prob_long_fitted, path = paste0(folder,"smoothed_probs_fitted.feather"))
```



#### Performances of decoding with Semi-Markov Model; fitted parameter values


The performances of the fitted model can be improved by validating/labelling more time-series (or by adding observation variables if any available).

To validate/label more time-series, one can use the shiny app in `HsMm_manual_labelling.Rmd`.



##### Accuracy

```{r idecod accuracy of fitted model}

# Viterbi Accuracy

A_V_f = mean(viterbi_states_fitted$correct_decoding, na.rm = TRUE)

cat("Accuracy of the viterbi decoding with model with fitted parameters: ",A_V_f,"\n")


# Smoothed Accuracy

A_f = mean(smoothed_states_fitted$correct_decoding, na.rm = TRUE)
cat("Accuracy of the model with initial parameters: ",A_f,"\n")

# mx = 1:nrow(labels)
# my = labels$state
# A_f = mean(smoothed_fitted$p[cbind(mx,my)], na.rm = TRUE)
# cat("Accuracy of the model with fitted parameters: ",A_f,"\n")

```

##### Confusion matrix

```{r idecod confusion matrix of fitted model}

confusion_matrix_viz = ggplot_confusion_matrix(
  true =  smoothed_states_fitted$manual_label_state_abbr,
  decoded = hsmm$states$abbr[smoothed_states_fitted$state_num])
confusion_matrix_viz + ggtitle("Backward/Forward decoding - fitted model")


confusion_matrix_viz = ggplot_confusion_matrix(
  true =  viterbi_states_fitted$manual_label_state_abbr,
  decoded = hsmm$states$abbr[viterbi_states_fitted$state_num])
confusion_matrix_viz + ggtitle("Viterbi decoding - fitted model")

```

##### Confidence in decoding



```{r idecod confidence in decoding fitted model - VIZ, fig.width=3.5, fig.height=3}

m = match(smoothed_states_fitted$correct_decoding,c(TRUE, FALSE, NA))
smoothed_states_fitted$decoding_accuracy = c("correct\ndecoding","incorrect\ndecoding","no\nmanual labels")[m]

confidence_score_dist_smoothed_fitted = ggplot(smoothed_states_fitted, aes(x = cs, fill = decoding_accuracy))
confidence_score_dist_smoothed_fitted = confidence_score_dist_smoothed_fitted +
  geom_histogram(binwidth = 0.05)+
  facet_grid(decoding_accuracy ~., scale = "free", drop = TRUE)+
  scale_fill_manual(values = c("seagreen3","salmon","gray70"))+
  xlab("confidence score")+
  guides(fill = FALSE)

confidence_score_dist_smoothed_fitted

ggsave(confidence_score_dist_smoothed_fitted, filename = str_c(IO$panels,"confidence_score_dist_smoothed_fitted.pdf"),
       width = viz$full_width/3, height = viz$full_width/4)


m = match(viterbi_states_fitted$correct_decoding,c(TRUE, FALSE, NA))
viterbi_states_fitted$decoding_accuracy = c("correct\ndecoding","incorrect\ndecoding","no\nmanual labels")[m]

confidence_score_dist_viterbi_fitted = ggplot(viterbi_states_fitted, aes(x = cs, fill = decoding_accuracy))
confidence_score_dist_viterbi_fitted = confidence_score_dist_viterbi_fitted +
  geom_histogram(binwidth = 0.05)+
  facet_grid(decoding_accuracy ~., scale = "free", drop = TRUE)+
  scale_fill_manual(values = c("seagreen3","salmon","gray70"))+
  xlab("confidence score")+
  guides(fill = FALSE)

confidence_score_dist_viterbi_fitted

ggsave(confidence_score_dist_viterbi_fitted, filename = str_c(IO$panels,"confidence_score_dist_viterbi_fitted.pdf"),
       width = viz$full_width/3, height = viz$full_width/4)

```



```{r idecod confidence in decoding fitted model per state}



ggplot(viterbi_states_fitted %>% dplyr::filter(correct_decoding))+
  geom_histogram(aes(x = loglik_b), binwidth = 0.1, fill = "red")+
  geom_histogram(aes(x = loglik), binwidth = 0.1, fill = "blue", alpha = 0.4)+
  facet_grid(state_num + state_name ~., scale = "free")


ggplot(viterbi_states_fitted %>% dplyr::filter(correct_decoding))+
  geom_histogram(aes(x = cs), binwidth = 0.01)+
  facet_grid(state_num + state_name ~., scale = "free")



ggplot(viterbi_states_fitted %>% dplyr::filter(!correct_decoding))+
  geom_histogram(aes(x = loglik_b), binwidth = 0.1, fill = "red")+
  geom_histogram(aes(x = loglik), binwidth = 0.1, fill = "blue", alpha = 0.4)+
  facet_grid(state_num + state_name ~., scale = "free")


ggplot(viterbi_states_fitted %>% dplyr::filter(!correct_decoding))+
  geom_histogram(aes(x = cs), binwidth = 0.01)+
  facet_grid(state_num + state_name ~., scale = "free")



```


##### Special events timing accuracy


```{r event accuracy for smoothed and viterbi fitted model}

smoothed_event_accuracy = event_accuracy(decoding = smoothed_states_fitted, 
                                         manual_labels = manual_labels, 
                                         events = c("Ovu", "Birth","Loss"))

smoothed_fitted_event_accuracy_plot = ggplot_event_accuracy(event_accuracy = smoothed_event_accuracy)

smoothed_fitted_event_accuracy_plot



viterbi_event_accuracy = event_accuracy(decoding = viterbi_states_fitted, 
                                         manual_labels = manual_labels, 
                                         events = c("Ovu", "Birth","Loss"))

viterbi_fitted_event_accuracy_plot = ggplot_event_accuracy(event_accuracy = viterbi_event_accuracy)

viterbi_fitted_event_accuracy_plot


```


##### Sequences with many days of incorrect decoding

```{r bad decoding sequences fitted model}

# Viterbi

decoding_agg_viterbi_fitted = viterbi_states_fitted %>% 
  group_by(user_id) %>% 
  dplyr::summarise(n_days = n(),
                   n_days_incorrect_decoding = sum(!correct_decoding, na.rm = TRUE),
                   percent_incorrect_decoding = n_days_incorrect_decoding/n_days *100) %>% 
  arrange(desc(percent_incorrect_decoding)) %>% 
  dplyr::mutate(user_id = factor(user_id, levels = user_id))

perc_of_incorrect_decoding_per_user_viterbi_fitted = 
  ggplot(decoding_agg_viterbi_fitted, aes(x = rev(user_id), y = percent_incorrect_decoding))+
  geom_bar(stat = "identity")+
  coord_flip()

perc_of_incorrect_decoding_per_user_viterbi_fitted + ggtitle("Viterbi; fitted parameters")

# Smoothed

decoding_agg_smooted_fitted = smoothed_states_fitted %>% 
  group_by(user_id) %>% 
  dplyr::summarise(n_days = n(),
                   n_days_incorrect_decoding = sum(!correct_decoding, na.rm = TRUE),
                   percent_incorrect_decoding = n_days_incorrect_decoding/n_days *100) %>% 
  arrange(desc(percent_incorrect_decoding)) %>% 
  dplyr::mutate(user_id = factor(user_id, levels = user_id))

perc_of_incorrect_decoding_per_user_smoothed_fitted = 
  ggplot(decoding_agg_smooted_fitted, aes(x = rev(user_id), y = percent_incorrect_decoding))+
  geom_bar(stat = "identity")+
  coord_flip()

perc_of_incorrect_decoding_per_user_smoothed_fitted + ggtitle("Forward-Backward; fitted parameters")
  
for(user in decoding_agg_smooted_fitted$user_id[1:10]){
  d = days %>% dplyr::filter(user_id == user)
  dec = smoothed_states_fitted %>% dplyr::filter(user_id == user) %>% 
    dplyr::mutate(cs = 1)
  
  states_labels_list = list(
    smoothed =  dec %>% dplyr::select(user_id, rel_date, color, cs) %>%  
      mutate(name = "Smoothed"), 
    difference_with_ground_truth = dec %>% 
      mutate(color = c("red","steelblue2")[correct_decoding+1], name = "Diff w/\nground truth") %>% 
      dplyr::select(user_id, rel_date, color, alpha = cs),
    manual_labels = manual_labels %>% dplyr::filter(user_id == user)%>%  
      mutate(name = "States\n(manual labels)")
  )
  
  try({
    p = plot_user_history(d = d, states_labels_list = states_labels_list)
    print(p)
  })
  
}


```


## Comparison of decodings

### Accuracies

#### Rule-based

```{r}

A_rb

```


#### Semi-Markov model, initial parameters

Viterbi:

```{r}
A_V_i
```

Forward/Backward (smoothed):

```{r}
A_i
```



#### Semi-Markov model, fitted parameters

Viterbi:

```{r idecod comparison of accuracies Viterbi decoding}

A_V_f

```

Forward/Backward (smoothed):

```{r idecod comparison of accuracies}

A_f

```


### Confusion matrices

```{r}


confusion_matrix_viz_rule_based = ggplot_confusion_matrix(
  true =  rule_based_decoding$manual_label_state_abbr,
  decoded = hsmm$states$abbr[rule_based_decoding$state_num])
confusion_matrix_viz_rule_based + ggtitle("Rule-based")


confusion_matrix_smoothed_init = ggplot_confusion_matrix(
  true =  smoothed_states_init$manual_label_state_abbr,
  decoded = hsmm$states$abbr[smoothed_states_init$state_num])
confusion_matrix_smoothed_init + ggtitle("Forward-Backward; initial parameters")

confusion_matrix_viterbi_init = ggplot_confusion_matrix(
  true =  viterbi_states_init$manual_label_state_abbr,
  decoded = hsmm$states$abbr[viterbi_states_init$state_num])
confusion_matrix_viterbi_init + ggtitle("Viterbi; initial parameters")



confusion_matrix_smoothed_fitted = ggplot_confusion_matrix(
  true =  smoothed_states_fitted$manual_label_state_abbr,
  decoded = hsmm$states$abbr[smoothed_states_fitted$state_num])
confusion_matrix_smoothed_fitted + ggtitle("Forward-Backward; fitted parameters")

confusion_matrix_viterbi_fitted = ggplot_confusion_matrix(
  true =  viterbi_states_fitted$manual_label_state_abbr,
  decoded = hsmm$states$abbr[viterbi_states_fitted$state_num])
confusion_matrix_viterbi_fitted + ggtitle("Viterbi; fitted parameters")


```


### Timing of special events

```{r}
baseline_event_accuracy_plot + ggtitle("Rule-based")

smoothed_init_event_accuracy_plot + ggtitle("Forward-Backward; initial parameters")
viterbi_init_event_accuracy_plot + ggtitle("Viterbi; initial parameters")

smoothed_fitted_event_accuracy_plot + ggtitle("Forward-Backward; fitted parameters")
viterbi_fitted_event_accuracy_plot + ggtitle("Viterbi; fitted parameters")

```



### Confidence scores

```{r}

confidence_score_dist_smoothed_init + ggtitle("Forward-Backward; initial parameters")
confidence_score_dist_viterbi_init + ggtitle("Viterbi; initial parameters")


confidence_score_dist_smoothed_fitted + ggtitle("Forward-Backward; fitted parameters")
confidence_score_dist_viterbi_fitted + ggtitle("Viterbi; fitted parameters")


```

### Users by fraction of incorrect labelling

```{r}

perc_max = max(decoding_agg_rule_based$percent_incorrect_decoding,
               decoding_agg_viterbi_init$percent_incorrect_decoding,
               decoding_agg_smooted_init$percent_incorrect_decoding,
               decoding_agg_viterbi_fitted$percent_incorrect_decoding,
               decoding_agg_smooted_fitted$percent_incorrect_decoding)

perc_of_incorrect_decoding_per_user_rule_based + ggtitle("Rule-based") + ylim(c(0,perc_max))
perc_of_incorrect_decoding_per_user_viterbi_init + ggtitle("Viterbi; initial parameters") + ylim(c(0,perc_max))
perc_of_incorrect_decoding_per_user_smoothed_init + ggtitle("Forward-Backward; initial parameters") + ylim(c(0,perc_max))
perc_of_incorrect_decoding_per_user_viterbi_fitted + ggtitle("Viterbi; fitted parameters") + ylim(c(0,perc_max))
perc_of_incorrect_decoding_per_user_smoothed_fitted + ggtitle("Forward-Backward; fitted parameters") + ylim(c(0,perc_max))

```





### Emission parameters

```{r idecod comparison emission parameters}

source("Scripts/00_functions_viz.R")
# Visualizing the initial and fitted parameters
viz_em_parm(p1 = hsmm_init$parms.emission, p2 = hsmm_fitted$model$parms.emission, hsmm = hsmm)

```














